(window.webpackJsonp=window.webpackJsonp||[]).push([[355],{643:function(e,t,n){"use strict";n.r(t);var r=n(14),a=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"python程序性能优化实战2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#python程序性能优化实战2"}},[e._v("#")]),e._v(" Python程序性能优化实战2")]),e._v(" "),t("h2",{attrs:{id:"reference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[e._v("#")]),e._v(" Reference")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://pythonspeed.com/articles/optimizing-dithering/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://pythonspeed.com/articles/optimizing-dithering/ - Python⇒Speed"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("‍")]),e._v(" "),t("h2",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),t("p",[e._v("The common advice when Python is too slow is to switch to a low-level compiled language like Cython or Rust. But what do you do if "),t("em",[e._v("that")]),e._v(" code is too slow? At that point you might start thinking about parallelism: using multi-threading or multi-processing so you can take advantage of multiple CPU cores.")]),e._v(" "),t("p",[e._v("But parallelism comes with its own set of complexities; at the very least, some algorithms can only really work in a single-threaded way. So what can you do?")]),e._v(" "),t("p",[t("strong",[e._v("As it turns out, there’s often still plenty of performance improvements you can get just by tweaking your low-level code.")]),e._v("  As a real-world example, in this article we’ll go about optimizing Floyd-Steinberg error diffusion dithering. The specific variant of the algorithm that we will implement converts a grayscale image with values of 0 to 255 into an image with just two colors, black and white.")]),e._v(" "),t("p",[e._v("Because of the specifics of this algorithm, it’s quite difficult or perhaps even impossible to parallelize with threading. But you can still make it run faster.")]),e._v(" "),t("blockquote",[t("p",[e._v("**This article is an excerpt from a book I’m working on that will help **​****​ "),t("strong",[e._v(", the kind of code you’d write with C, Cython, or Rust.")]),e._v("  The goal is to help data scientists and scientists who normally write Python to understand how to make their compiled code faster.")])]),e._v(" "),t("p",[e._v("‍")]),e._v(" "),t("h2",{attrs:{id:"the-floyd-steinberg-dithering-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-floyd-steinberg-dithering-algorithm"}},[e._v("#")]),e._v(" The Floyd-Steinberg dithering algorithm")]),e._v(" "),t("p",[e._v("As explained in the "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering",target:"_blank",rel:"noopener noreferrer"}},[e._v("Wikipedia article"),t("OutboundLink")],1),e._v(", we can use this algorithm to convert a grayscale image into just two colors, black and white. The algorithm rounds a pixel’s value to the nearest of the two extremes (0 for black or 255 for white). The difference between the original value and the rounded value, known as the error, is added to neighboring pixels, with the following distribution:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[ ...            , current pixel (rounded)   , + 7/16 of error, ... ]\n[ + 3/16 of error, + 5/16 of error           , + 1/16 of error, ... ]\n")])])]),t("p",[e._v("So the next pixel on the row gets 7/16th of the error, and the pixel one row down gets 5/16th of the error, and so on. Once the current pixel is processed, the algorithm moves on to the next pixel, which now includes some of the error from the previous pixel.")]),e._v(" "),t("p",[e._v("One key issue with optimizing this algorithm is that it’s likely impossible to process pixels in parallel: each pixel’s final value is impacted by the calculations done on previous pixels. This suggests that using multiple threads for parallelism might be difficult or impossible; using SIMD may also be difficult (see below for a quick explanation of SIMD). Still, given a naive implementation there are some ways to speed things up.")]),e._v(" "),t("p",[e._v("Let’s load the libraries we’ll be using, as well as a test image, a 400×400 NumPy array of "),t("code",[e._v("uint8")]),e._v("​s.")]),e._v(" "),t("p",[e._v("Like "),t("a",{attrs:{href:"https://pythonspeed.com/producs/lowlevelcode/",target:"_blank",rel:"noopener noreferrer"}},[e._v("the book"),t("OutboundLink")],1),e._v(", the examples in this article all use "),t("a",{attrs:{href:"https://pythonspeed.com/articles/numba-faster-python/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Numba"),t("OutboundLink")],1),e._v(", so you only need to understand Python syntax. If you decorate a function with "),t("code",[e._v("@numba.njit")]),e._v("​, Numba will compile it into low-level machine code, at runtime. Even if you’re not using Numba, the same basic optimizations techniques and concepts will apply to C++, Rust, or other low-level compiled languages.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('from numba import njit\nimport numpy as np\nfrom skimage import io\n\nimage = io.imread("images/hallway.jpg")\n')])])]),t("p",[e._v("Here’s what it looks like:")]),e._v(" "),t("p",[e._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/cell-2-output-2-20231107143557-7cwwik0.png",alt:"The original image"}}),e._v("​")]),e._v(" "),t("p",[e._v("If this was more than an example, we’d want to benchmark the code with a variety of images and sizes, matching the variety of inputs we expect to encounter. For simplicity’s sake, however, we’ll stick to this single image.")]),e._v(" "),t("p",[e._v("In the following section you’ll follow along as I start with a naive implementation, make it faster, reduce memory usage, and then optimize it some more. Some intermediate steps and failed experiments were omitted for clarity. Nonetheless, this is a real optimization exercise: these are all optimization ideas I came up with as I went along, as I had never optimized this algorithm before.")]),e._v(" "),t("h2",{attrs:{id:"a-naive-implementation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-naive-implementation"}},[e._v("#")]),e._v(" A naive implementation")]),e._v(" "),t("p",[e._v("Here’s the first version I implemented. I didn’t try to make it slow or fast: I just tried to implement the algorithm.")]),e._v(" "),t("p",[e._v("The code stores temporary results in 16-bit integers, because adding the error might make some pixels either negative or bigger than 255. Both those cases won’t fit in an unsigned 8-bit integer. At the end I turn the result into an 8-bit image, which is what the function is supposed to return.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# Code that is decorated with numba.njit looks like Python code, but is\n# actually compiled into machine code, at runtime. This is fast, low-level\n# code!\n@njit\ndef dither(img):\n    # Allow negative values and wider range than a uint8 has:\n    result = img.astype(np.int16)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    last_y = y_size - 1\n    last_x = x_size - 1\n    for y in range(y_size):\n        for x in range(x_size):\n            old_value = result[y, x]\n            if old_value < 0:\n                new_value = 0\n            elif old_value > 255:\n                new_value = 255\n            else:\n                new_value = np.uint8(np.round(old_value / 255.0)) * 255\n            result[y, x] = new_value\n            # We might get a negative value for the error:\n            error = np.int16(old_value) - new_value\n            if x < last_x:\n                result[y, x + 1] += error * 7 // 16\n            if y < last_y and x > 0:\n                result[y + 1, x - 1] += error * 3 // 16\n            if y < last_y:\n                result[y + 1, x] += error * 5 // 16\n            if y < last_y and x < last_x:\n                result[y + 1, x + 1] += error // 16\n\n    return result.astype(np.uint8)\n\nbaseline_result = dither(image)\n")])])]),t("p",[e._v("Here’s what it looks like:")]),e._v(" "),t("p",[e._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/cell-4-output-2-20231107143557-7zqwzz1.png",alt:"The dithered image"}}),e._v("​")]),e._v(" "),t("p",[e._v("And here’s how long it takes to run:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (milliseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("2.3")])])])]),e._v(" "),t("h2",{attrs:{id:"some-concepts-you-should-know"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#some-concepts-you-should-know"}},[e._v("#")]),e._v(" Some concepts you should know")]),e._v(" "),t("p",[e._v("The optimizations we’ll use below rely on concepts that are covered in much more detail in "),t("a",{attrs:{href:"https://pythonspeed.com/products/lowlevelcode/",target:"_blank",rel:"noopener noreferrer"}},[e._v("the book it’s based on"),t("OutboundLink")],1),e._v(". To help you understand this article on its own, however, here are some quick explanations:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Instruction-level parallelism (ILP):")]),e._v("  Your CPU can transparently run multiple operations in parallel, on a single CPU core, so long as they don’t depend on each other. In other words, ILP makes your code faster without any work on your part, at least when it’s possible.")]),e._v(" "),t("li",[t("strong",[e._v("Branch prediction:")]),e._v("  To help with ILP, your CPU will try to predict whether or not branches—"),t("code",[e._v("if")]),e._v("​ statements and the like—will be taken. If the prediction is wrong, your code will get a lot slower as the CPU needs to undo the speculative work it did.")]),e._v(" "),t("li",[t("strong",[e._v("SIMD (Single Instruction, Multiple Data):")]),e._v("  If the compiler emits the right CPU instructions, the CPU can do the same operation, for example adding a number, to multiple numbers at the same time with a single instruction.")]),e._v(" "),t("li",[e._v("**Memory hierarchy:**​"),t("a",{attrs:{href:"https://pythonspeed.com/articles/performance-memory-locality/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Reading and writing from memory is slow"),t("OutboundLink")],1),e._v(", so your CPU has caches (L1, L2, L3) to speed up access. Your CPU also has a small number of extra-fast “registers”, locations where it can keep small values like 64-bit numbers and run operations directly on the values.")])]),e._v(" "),t("p",[e._v("All these concepts and how they can help you speed up your code will be covered in far more detail in "),t("a",{attrs:{href:"https://pythonspeed.com/products/lowlevelcode/",target:"_blank",rel:"noopener noreferrer"}},[e._v("the upcoming book"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"considering-what-to-optimize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#considering-what-to-optimize"}},[e._v("#")]),e._v(" Considering what to optimize")]),e._v(" "),t("p",[e._v("In general, we want to make the inner part of the loop as fast as possible. Looking at the error diffusion part of the part of the code, instruction-level parallelism ought to help speed up running the code, given that each calculation is independent:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if x < last_x:\n    result[y, x + 1] += error * 7 // 16\nif y < last_y and x > 0:\n    result[y + 1, x - 1] += error * 3 // 16\nif y < last_y:\n    result[y + 1, x] += error * 5 // 16\nif y < last_y and x < last_x:\n    result[y + 1, x + 1] += error // 16\n")])])]),t("p",[e._v("What about all those branches—will branch misprediction make them slow? A little thought suggests that these branches are very predictable because they depend only on the pixel location. Consider a 6×6 image: depending on the location of a pixel in the image, different combinations of branches will be taken.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1 2 2 2 2 3\n1 2 2 2 2 3\n1 2 2 2 2 3\n1 2 2 2 2 3\n1 2 2 2 2 3\n4 5 5 5 5 6\n")])])]),t("p",[e._v("For example, pixels in zones 1 and 4 won’t be able to diffuse the error to the previous column, because there is no previous column. Therefore the relevant branch ("),t("code",[e._v("if y < last_y and x > 0")]),e._v("​) won’t be taken.")]),e._v(" "),t("p",[e._v("In larger images, virtually all the pixels will be in zone 2, with the exact same branches taken, so the CPU ought to be able to reliably predict those branches. Thus a reasonable assumption is that the diffusion part of the code is running at a decent speed even in its current state.")]),e._v(" "),t("p",[e._v("In contrast, the calculation of the error itself seems potentially slow:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if old_value < 0:\n    new_value = 0\nelif old_value > 255:\n    new_value = 255\nelse:\n    new_value = np.uint8(np.round(old_value / 255.0)) * 255\n")])])]),t("p",[e._v("First, the branches depend on the values of the pixels, so they may be hard for the CPU to predict, and it’s not clear whether the compiler will generate branchless code. Second, there’s some relatively complex math going on: rounding a float seems like it would be slow.")]),e._v(" "),t("h2",{attrs:{id:"optimizing-rounding"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optimizing-rounding"}},[e._v("#")]),e._v(" Optimizing rounding")]),e._v(" "),t("p",[e._v("The naive rounding implementation addresses three possible cases for intermediate pixel values:")]),e._v(" "),t("ol",[t("li",[e._v("Negative numbers should be rounded to 0 (black).")]),e._v(" "),t("li",[e._v("Numbers larger than 255 should be rounded 255 (white).")]),e._v(" "),t("li",[e._v("Numbers in between should be rounded to the closest of 0 to 255.")])]),e._v(" "),t("p",[e._v("All of this can be simplified into a single simple check: measuring whether the pixel value is smaller or bigger than the middle point. In Python: "),t("code",[e._v("new_value = 0 if old_value < 128 else 255")]),e._v("​. Since "),t("code",[e._v("new_value")]),e._v("​ gets a value set in either case, the hope is that the compiler will turn this into branchless code, so we don’t have to worry about the cost of branch misprediction.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@njit\ndef dither2(img):\n    result = img.astype(np.int16)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    last_y = y_size - 1\n    last_x = x_size - 1\n    for y in range(y_size):\n        for x in range(x_size):\n            old_value = result[y, x]\n            # Branchless, simple rounding:\n            new_value = 0 if old_value < 128 else 255\n            result[y, x] = new_value\n            error = old_value - new_value\n            if x < last_x:\n                result[y, x + 1] += error * 7 // 16\n            if y < last_y and x > 0:\n                result[y + 1, x - 1] += error * 3 // 16\n            if y < last_y:\n                result[y + 1, x] += error * 5 // 16\n            if y < last_y and x < last_x:\n                result[y + 1, x + 1] += error // 16\n    return result.astype(np.uint8)\n\nassert np.array_equal(dither2(image), baseline_result)\n")])])]),t("p",[e._v("Here’s how long it takes to run:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (microseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither2(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("830.7")])])])]),e._v(" "),t("p",[e._v("That’s a lot better! Remember, 1000 microseconds is 1 millisecond.")]),e._v(" "),t("h2",{attrs:{id:"optimizing-memory-usage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optimizing-memory-usage"}},[e._v("#")]),e._v(" Optimizing memory usage")]),e._v(" "),t("p",[e._v("While the code is now a lot faster, there’s another problem to consider: it’s using quite a lot of memory. The input image uses N bytes of memory, one "),t("code",[e._v("uint8")]),e._v("​ per pixel. "),t("code",[e._v("dither()")]),e._v("​ and "),t("code",[e._v("dither2()")]),e._v("​ both allocate 3N bytes: an "),t("code",[e._v("int16")]),e._v("​ array costs 2 bytes per pixel, and the final "),t("code",[e._v("uint8")]),e._v("​ result array is an additional byte per pixel.")]),e._v(" "),t("p",[e._v("We can improve this by noticing that intermediate error accumulation only happens on the current row and the next row. And once we’re done with a row it always fits in 8 bits and never changes again. So we really only need to keep 2 rows worth of memory as "),t("code",[e._v("int16")]),e._v("​, and we can reuse the same memory as we traverse the image:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@njit\ndef dither3(img):\n    result = np.empty(img.shape, dtype=np.uint8)\n    # Temporary storage of current and next row's intermediate values:\n    staging = img[0:2].astype(np.int16)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    last_x = x_size - 1\n    for y in range(y_size):\n        for x in range(x_size):\n            old_value = staging[0, x]\n            new_value = 0 if old_value < 128 else 255\n            staging[0, x] = new_value\n            error = old_value - new_value\n            if x < last_x:\n                staging[0, x + 1] += error * 7 // 16\n            if x > 0:\n                staging[1, x - 1] += error * 3 // 16\n            staging[1, x] += error * 5 // 16\n            if x < last_x:\n                staging[1, x + 1] += error // 16\n\n        # Copy current row of staging into result:\n        result[y,:] = staging[0,:]\n        # Prepare staging area for next iteration:\n        staging[0,:] = staging[1,:]\n        if y < y_size - 2:\n            staging[1,:] = img[y + 2,:]\n    return result\n\nassert np.array_equal(dither3(image), baseline_result)\n")])])]),t("p",[e._v("Here’s how long it takes to run:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (microseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither3(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("909.6")])])])]),e._v(" "),t("p",[e._v("That’s a little slower than "),t("code",[e._v("dither2()")]),e._v("​, but still a lot faster than the original naive implementation. And now peak memory allocation is approximately N bytes, since the staging array doesn’t use much memory. Put another way, this version cuts memory usage by two-thirds.")]),e._v(" "),t("h2",{attrs:{id:"gaining-back-some-performance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gaining-back-some-performance"}},[e._v("#")]),e._v(" Gaining back some performance")]),e._v(" "),t("p",[e._v("The new version is probably slower because it does a bunch of copying. Once processing the current row is done, the contents of the next row ("),t("code",[e._v("staging[1]")]),e._v("​) has to be copied into the current row ("),t("code",[e._v("staging[0]")]),e._v("​), in order to preserve the errors diffused to the next row. If we split our staging array into two, one for the current row and one for the next row, we can just swap those two arrays instead of copying the data.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@njit\ndef dither4(img):\n    result = np.empty(img.shape, dtype=np.uint8)\n    # Two arrays, one for staging the current row and one for the next:\n    staging_current = img[0].astype(np.int16)\n    staging_next = img[1].astype(np.int16)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    last_x = x_size - 1\n    for y in range(y_size):\n        for x in range(x_size):\n            old_value = staging_current[x]\n            new_value = 0 if old_value < 128 else 255\n            staging_current[x] = new_value\n            error = old_value - new_value\n            if x < last_x:\n                staging_current[x + 1] += error * 7 // 16\n            if x > 0:\n                staging_next[x - 1] += error * 3 // 16\n            staging_next[x] += error * 5 // 16\n            if x < last_x:\n                staging_next[x + 1] += error // 16\n\n        # Copy current row of staging into result:\n        result[y,:] = staging_current[:]\n        # Switch the next row to be the current one, and copy in the next row's\n        # initial data from the original image:\n        staging_current, staging_next = staging_next, staging_current\n        if y < y_size - 2:\n            staging_next[:] = img[y + 2,:]\n\n    return result\n\nassert np.array_equal(dither4(image), baseline_result)\n")])])]),t("p",[e._v("Here’s how long it takes to run:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (microseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither4(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("876.6")])])])]),e._v(" "),t("p",[e._v("That’s slightly better.")]),e._v(" "),t("h2",{attrs:{id:"going-even-faster"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#going-even-faster"}},[e._v("#")]),e._v(" Going even faster")]),e._v(" "),t("p",[e._v("We still have all those annoying "),t("code",[e._v("if")]),e._v("​ statements in the main loop, which are used to handle edge pixels. For example, if you’re in the first column, it’s not possible to diffuse the errors to the previous column.")]),e._v(" "),t("p",[e._v("We can get rid of those conditionals, though. The code currently has temporary staging arrays for accumulating errors, and there’s no reason they have to be the same size as the input or the result. We can just add an extra item at the start and end. As a result edge pixels can behave the same way as non-edge pixels, and we can get rid of the conditionals.")]),e._v(" "),t("p",[e._v("As an additional optimization, notice that copying "),t("code",[e._v("staging_current")]),e._v("​ into the "),t("code",[e._v("result")]),e._v("​ array isn’t actually necessary. Once a pixel is finalized, it won’t change, so we can just write directly to "),t("code",[e._v("result")]),e._v("​ and skip updating "),t("code",[e._v("staging_current")]),e._v("​.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@njit\ndef dither5(img):\n    result = np.empty(img.shape, dtype=np.uint8)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    # The staging arrays have an extra entry at the start and at the end, so\n    # that we don't need conditionals to handle edge pixels.\n    staging_current = np.zeros(x_size + 2, np.int16)\n    staging_current[1:-1] = img[0]\n    staging_next = np.zeros(x_size + 2, np.int16)\n\n    for y in range(y_size):\n        # Copy in the next row's data:\n        if y < y_size - 1:\n            staging_next[1:-1] = img[y + 1,:]\n\n        for x in range(x_size):\n            old_value = staging_current[x + 1]\n            new_value = 0 if old_value < 128 else 255\n            # This is the final result, so we can store it directly in the\n            # result:\n            result[y, x] = new_value\n            error = old_value - new_value\n            staging_current[x + 2] += error * 7 // 16\n            staging_next[x] += error * 3 // 16\n            staging_next[x + 1] += error * 5 // 16\n            staging_next[x + 2] += error // 16\n\n        # Switch the next row to be the current one:\n        staging_current, staging_next = staging_next, staging_current\n\n    return result\n\nassert np.array_equal(dither5(image), baseline_result)\n")])])]),t("p",[e._v("Here’s how long it takes to run:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (microseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither5(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("816")])])])]),e._v(" "),t("h2",{attrs:{id:"reducing-memory-reads-and-writes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reducing-memory-reads-and-writes"}},[e._v("#")]),e._v(" Reducing memory reads and writes")]),e._v(" "),t("p",[e._v("We can do even better! We’re doing a lot of reading and writing from "),t("code",[e._v("staging_current")]),e._v("​ and "),t("code",[e._v("staging_next")]),e._v("​, and this isn’t strictly necessary. If we can move some of the temporary integer values we’re accumulating to variables on the stack, they will likely end up being stored in CPU registers. Reading and writing from registers is faster than reading and writing memory, even when the CPU is using a fast cache to speed up the latter.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@njit\ndef dither6(img):\n    result = np.empty(img.shape, dtype=np.uint8)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    staging_current = np.zeros(x_size + 2, np.int16)\n    staging_current[1:-1] = img[0]\n    staging_next = np.zeros(x_size + 2, np.int16)\n\n    for y in range(y_size):\n        right_pixel_error = 0\n        downleft_prev_error = 0\n        downleft_prevprev_error = 0\n        for x in range(x_size):\n            old_value = staging_current[x + 1] + right_pixel_error\n            new_value = 0 if old_value < 128 else 255\n            result[y, x] = new_value\n            error = old_value - new_value\n            right_pixel_error = error * 7 // 16\n            # Now that we have all three sets of errors accumulated, store\n            # them:\n            staging_next[x] = (\n                img[y + 1, x - 1] + downleft_prev_error + error * 3 // 16\n            )\n            # Accumulate errors for the next iteration:\n            downleft_prev_error = downleft_prevprev_error + error * 5 // 16\n            downleft_prevprev_error = error // 16\n\n        # Update the final pixel in the next row; it only gets two diffused\n        # errors, not three, so it doesn't get updated in the inner loop.\n        staging_next[x_size] = img[y + 1, x_size - 1] + downleft_prev_error\n\n        staging_current, staging_next = staging_next, staging_current\n\n    return result\n\nassert np.array_equal(dither6(image), baseline_result)\n")])])]),t("p",[e._v("Comparing our updated code to the previous version:")]),e._v(" "),t("ul",[t("li",[e._v("Previously we read twice and wrote once to "),t("code",[e._v("staging_current")]),e._v("​ in every inner loop iteration. Now we only read once, and don’t write at all.")]),e._v(" "),t("li",[e._v("Previously we read and wrote to "),t("code",[e._v("staging_next")]),e._v("​ three times in every inner loop iteration, and overwrote it once per outer loop. Now we only write once in every inner loop iteration, and don’t read at all.")])]),e._v(" "),t("p",[e._v("Here’s how long it takes to run:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (microseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither6(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("602.7")])])])]),e._v(" "),t("p",[e._v("This version of the code is slightly harder to understand, but hopefully it’s not too bad.")]),e._v(" "),t("h2",{attrs:{id:"relaxing-our-accuracy-requirements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#relaxing-our-accuracy-requirements"}},[e._v("#")]),e._v(" Relaxing our accuracy requirements")]),e._v(" "),t("p",[e._v("So far each optimized version made sure the results exactly matched the original version. This was helpful for catching bugs, but it’s not necessary. Dithering is a visual effect; most of the time, as long as it looks right, that’s all that matters.")]),e._v(" "),t("p",[e._v("If we’re willing to accept slightly different results, we can centralize the division by 16. Since rounding the fractions happens slightly differently, the results are slightly different, but that’s fine.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@njit\ndef dither7(img):\n    result = np.empty(img.shape, dtype=np.uint8)\n    y_size = img.shape[0]\n    x_size = img.shape[1]\n    staging_current = np.zeros(x_size + 2, np.int16)\n    staging_current[1:-1] = img[0]\n    staging_next = np.zeros(x_size + 2, np.int16)\n\n    for y in range(y_size):\n        right_pixel_error = 0\n        downleft_prev_error = 0\n        downleft_prevprev_error = 0\n        for x in range(x_size):\n            old_value = staging_current[x + 1] + right_pixel_error\n            new_value = 0 if old_value < 128 else 255\n            result[y, x] = new_value\n            error = old_value - new_value\n            right_pixel_error = error * 7 // 16\n            staging_next[x] = (\n                img[y + 1, x - 1] + (downleft_prev_error + error * 3) // 16\n            )\n            # Don't divide by 16 yet, only do that when we store final version\n            # in staging_next:\n            downleft_prev_error = downleft_prevprev_error + error * 5\n            downleft_prevprev_error = error\n\n        staging_next[x_size] = (\n            img[y + 1, x_size - 1] + downleft_prev_error // 16\n        )\n\n        staging_current, staging_next = staging_next, staging_current\n\n    return result\n")])])]),t("p",[e._v("Here’s what it looks like:")]),e._v(" "),t("p",[e._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/cell-18-output-2-20231107143557-w94ginj.png",alt:"The dithered image"}}),e._v("​")]),e._v(" "),t("p",[e._v("And here’s a comparison to previous versions:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Code")]),e._v(" "),t("th",[e._v("Time to run (microseconds)")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("​"),t("code",[e._v("dither(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("2,339.5")])]),e._v(" "),t("tr",[t("td",[e._v("​"),t("code",[e._v("dither2(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("827.9")])]),e._v(" "),t("tr",[t("td",[e._v("​"),t("code",[e._v("dither3(image) # Bit slower, but reduces memory usage by 2/3rds")]),e._v("​")]),e._v(" "),t("td",[e._v("909.7")])]),e._v(" "),t("tr",[t("td",[e._v("​"),t("code",[e._v("dither4(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("875.3")])]),e._v(" "),t("tr",[t("td",[e._v("​"),t("code",[e._v("dither5(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("814.3")])]),e._v(" "),t("tr",[t("td",[e._v("​"),t("code",[e._v("dither6(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("601.7")])]),e._v(" "),t("tr",[t("td",[e._v("​"),t("code",[e._v("dither7(image)")]),e._v("​")]),e._v(" "),t("td",[e._v("553.9")])])])]),e._v(" "),t("p",[e._v("Can "),t("em",[e._v("you")]),e._v(" make this code even faster? If you give it a try and find some additional tricks, "),t("a",{attrs:{href:"mailto:itamar@pythonspeed.com"}},[e._v("let me know")]),e._v(". Note that some optimizations may be easier to identify and try if you go back and start from an earlier version of the code.")]),e._v(" "),t("p",[e._v("And if you’d like to understand the concepts these optimizations rely on—ILP, branch prediction, SIMD, and more—"),t("a",{attrs:{href:"https://pythonspeed.com/products/lowlevelcode/",target:"_blank",rel:"noopener noreferrer"}},[e._v("sign up to get notified when the book is released"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=a.exports}}]);