(window.webpackJsonp=window.webpackJsonp||[]).push([[262],{541:function(a,e,n){"use strict";n.r(e);var t=n(14),s=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"线程间数据隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程间数据隔离"}},[a._v("#")]),a._v(" 线程间数据隔离")]),a._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://pythontime.iswbm.com/en/latest/c02/c02_05.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://pythontime.iswbm.com/en/latest/c02/c02_05.html"),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"初步认识信息隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初步认识信息隔离"}},[a._v("#")]),a._v(" 初步认识信息隔离")]),a._v(" "),e("p",[a._v("什么是"),e("code",[a._v("信息隔离")]),a._v("？")]),a._v(" "),e("p",[a._v("比如说，咱有两个线程，线程A里的变量，和线程B里的变量值不能共享。这就是"),e("code",[a._v("信息隔离")]),a._v("。")]),a._v(" "),e("p",[a._v("你可能要说，那变量名取不一样不就好啦？")]),a._v(" "),e("p",[a._v("是的，如果所有的线程都不是由一个class实例化出来的同一个对象，确实是可以。这个问题我们暂且挂着，后面我再说明。")]),a._v(" "),e("p",[a._v("那么，如何实现"),e("code",[a._v("信息隔离")]),a._v("呢？")]),a._v(" "),e("p",[a._v("在Python中，其提供了"),e("code",[a._v("threading.local")]),a._v("这个类，可以很方便的控制变量的隔离，即使是同一个变量，在不同的线程中，其值也是不能共享的。")]),a._v(" "),e("p",[a._v("用代码来看下")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('from threading import local, Thread, currentThread\n\n# 定义一个local实例\nlocal_data = local()\n# 在主线中，存入name这个变量\nlocal_data.name = \'local_data\'\n\n\nclass MyThread(Thread):\n    def run(self):\n        print("赋值前-子线程：", currentThread(),local_data.__dict__)\n        # 在子线程中存入name这个变量\n        local_data.name = self.getName()\n        print("赋值后-子线程：",currentThread(), local_data.__dict__)\n\n\nif __name__ == \'__main__\':\n    print("开始前-主线程：",local_data.__dict__)\n\n    t1 = MyThread()\n    t1.start()\n    t1.join()\n\n    t2 = MyThread()\n    t2.start()\n    t2.join()\n\n    print("结束后-主线程：",local_data.__dict__)\n')])])]),e("p",[a._v("来看看输出结果")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("开始前-主线程： {'name': 'local_data'}\n\n赋值前-子线程： <MyThread(Thread-1, started 4832)> {}\n赋值后-子线程： <MyThread(Thread-1, started 4832)> {'name': 'Thread-1'}\n\n赋值前-子线程： <MyThread(Thread-2, started 5616)> {}\n赋值后-子线程： <MyThread(Thread-2, started 5616)> {'name': 'Thread-2'}\n\n结束后-主线程： {'name': 'local_data'}\n")])])]),e("p",[a._v("从输出来看，我们可以知道，"),e("code",[a._v("local")]),a._v("实际是一个"),e("code",[a._v("字典型")]),a._v("的对象，其内部可以以"),e("code",[a._v("key-value")]),a._v("的形式存入你要做信息隔离的变量。local实例可以是"),e("code",[a._v("全局唯一")]),a._v("的，只有一个。因为你在给local存入或访问变量时，它会根据当前的线程的不同从不同的"),e("code",[a._v("存储空间")]),a._v("存入或获取。")]),a._v(" "),e("p",[a._v("基于此，我们可以得出以下三点结论： >1. 主线程中的变量，不会因为其是全局变量，而被子线程获取到； 2. 主线程也不能获取到子线程中的变量； 3. 子线程与子线程之间的变量也不能互相访问。")]),a._v(" "),e("p",[a._v("所以如果想在当前线程保存一个全局值，并且各自线程（包括主线程）互不干扰，使用local类吧。")]),a._v(" "),e("h2",{attrs:{id:"_2-信息隔离的意义何在"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-信息隔离的意义何在"}},[a._v("#")]),a._v(" 2. 信息隔离的意义何在")]),a._v(" "),e("p",[a._v("细心的你，一定已经发现了，上面那个例子，即使我们不用"),e("code",[a._v("threading.local")]),a._v("来做信息隔离，两个线程"),e("code",[a._v("self.getName()")]),a._v("本身就是隔离的，没有任何关系的。因为这两个线程是由一个class实例出的两个不同的实例对象。自然是可以不用做隔离，因为其本身就是隔离的。")]),a._v(" "),e("p",[a._v("但是，现实开发中。不可排除有多个线程，是由一个class实例出的同一个实例对象而实现的。")]),a._v(" "),e("p",[a._v("譬如，现在新手特别喜欢的爬虫项目。通常都是先给爬虫一个主页，然后获取主页下的所有链接，对这个链接再进行遍历，一直往下，直到把所有的链接都爬完，获取到我们所需的内容。")]),a._v(" "),e("p",[a._v("由于单线程的爬取效率实在是太低了，我们考虑使用多线程来工作。先使用"),e("code",[a._v("socket")]),a._v("和"),e("code",[a._v("www.sina.con.cn")]),a._v("建立一个TCP连接。然后在这个连接的基础上，对主页上的每个链接（我们这里只举"),e("code",[a._v("news.sina.com.cn")]),a._v("和"),e("code",[a._v("blog.sina.com.cn")]),a._v("这两个子链接做例子）创建一个线程，这样效率就高多了。 >"),e("strong",[a._v("友情提醒")]),a._v("： >以下代码，若要理解，可能需要你了解下socket的网络编程相关内容。我在前几天的文章中有发布一篇相关的文章，没有基础的同学可以先去看看那篇文章。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import threading\nfrom functools import partial\nfrom socket import socket, AF_INET, SOCK_STREAM\n\nclass LazyConnection:\n    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):\n        self.address = address\n        self.family = AF_INET\n        self.type = SOCK_STREAM\n        self.local = threading.local()\n\n    def __enter__(self):\n        if hasattr(self.local, 'sock'):\n            raise RuntimeError('Already connected')\n        # 把socket连接存入local中\n        self.local.sock = socket(self.family, self.type)\n        self.local.sock.connect(self.address)\n        return self.local.sock\n\n    def __exit__(self, exc_ty, exc_val, tb):\n        self.local.sock.close()\n        del self.local.sock\n\ndef spider(conn, website):\n    with conn as s:\n        header = 'GET / HTTP/1.1\\r\\nHost: {}\\r\\nConnection: close\\r\\n\\r\\n'.format(website)\n        s.send(header.encode(\"utf-8\"))\n        resp = b''.join(iter(partial(s.recv, 100000), b''))\n    print('Got {} bytes'.format(len(resp)))\n\nif __name__ == '__main__':\n    # 建立一个TCP连接\n    conn = LazyConnection(('www.sina.com.cn', 80))\n\n    # 爬取两个页面\n    t1 = threading.Thread(target=spider, args=(conn,\"news.sina.com.cn\"))\n    t2 = threading.Thread(target=spider, args=(conn,\"blog.sina.com.cn\"))\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n")])])]),e("p",[a._v("输出结果")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Got 765 bytes\nGot 513469 bytes\n")])])]),e("p",[a._v("如果是在这种场景下，要做到线程之间的状态信息的隔离，就肯定要借助"),e("code",[a._v("threading.local")]),a._v("，所以"),e("code",[a._v("threading.local")]),a._v("的存在是有存在的意义的。其他还有很多场景是必须借助"),e("code",[a._v("threading.local")]),a._v("才能实现的，而这些就要靠你们在真正的业务开发中去发现咯。")])])}),[],!1,null,null,null);e.default=s.exports}}]);