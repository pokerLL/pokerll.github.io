(window.webpackJsonp=window.webpackJsonp||[]).push([[334],{613:function(a,t,v){"use strict";v.r(t);var _=v(14),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"浮点数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浮点数"}},[a._v("#")]),a._v(" 浮点数")]),a._v(" "),t("h2",{attrs:{id:"nan"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan"}},[a._v("#")]),a._v(" NaN")]),a._v(" "),t("p",[a._v("NaN（Not a Number）是指在计算机中出现的一种特殊的浮点数值，通常表示一个未定义或未知的数值。")]),a._v(" "),t("p",[a._v("NaN在科学计算中很常见，例如在测量中出现不确定的数据、除以0等情况都会产生NaN值。因此，正确地处理NaN值是科学计算中的重要问题之一。")]),a._v(" "),t("p",[a._v("在Python中，浮点数的NaN值可以通过float('nan')来创建。")]),a._v(" "),t("p",[a._v("NaN在计算中通常具有传染性，即当出现NaN参与计算时，计算结果也是NaN。在Python中，可以通过math.isnan()函数判断一个浮点数是否为NaN。")]),a._v(" "),t("p",[a._v("需要注意的是，NaN无论进行任何比较，其结果都不是相等，因此只建议使用"),t("code",[a._v("math.isnan")]),a._v("​进行相关的判断。")]),a._v(" "),t("blockquote",[t("p",[a._v("Python 中有个模块"),t("code",[a._v("fpectl")]),a._v("​用于控制无穷大或者NaN出现时Python的行为，但这个模块不是默认开启的。")])]),a._v(" "),t("p",[a._v("‍")]),a._v(" "),t("h2",{attrs:{id:"浮点数累积效应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浮点数累积效应"}},[a._v("#")]),a._v(" 浮点数累积效应")]),a._v(" "),t("p",[a._v("浮点数累积效应（floating-point accumulation error）指的是由于浮点数的精度有限而导致的计算误差累积的现象。在进行浮点数运算时，由于计算机存储浮点数时需要舍入，因此在多次计算的过程中，舍入误差会不断累积，最终可能导致计算结果与期望结果存在较大的误差。")]),a._v(" "),t("p",[a._v("例如，对于以下简单的浮点数计算：")]),a._v(" "),t("div",{staticClass:"language-cpp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.1")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.1")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.1")]),a._v("\n")])])]),t("p",[a._v("由于浮点数的精度有限，这个计算的结果可能会与期望结果 0.3 存在较大的误差。")]),a._v(" "),t("p",[a._v("为了避免浮点数累积效应带来的误差，可以采用以下方法：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("尽量减少浮点数的计算次数，尤其是连续的加减运算。")]),a._v(" "),t("p",[a._v("对于示例，"),t("code",[a._v("0.1 * 3")]),a._v("​就优于 "),t("code",[a._v("0.1 + 0.1 + 0.1")]),a._v("​")])]),a._v(" "),t("li",[t("p",[a._v("尽量避免比较两个浮点数是否相等，因为由于舍入误差的存在，即使两个浮点数非常接近，它们也可能不相等。可以采用一些技巧，如比较它们之间的差值是否小于一个很小的阈值。")])]),a._v(" "),t("li",[t("p",[a._v("使用 decimal 模块代替内置的 float 类型进行精确计算。decimal 模块支持任意精度的十进制数，可以避免浮点数累积效应带来的误差。")])]),a._v(" "),t("li",[t("p",[a._v("使用 numpy 或者 scipy 等科学计算库，它们提供了更加精确的浮点数计算方法，可以避免浮点数累积效应带来的误差。")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);