(window.webpackJsonp=window.webpackJsonp||[]).push([[276],{555:function(t,a,s){"use strict";s.r(a);var n=s(14),v=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"命名空间和作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间和作用域"}},[t._v("#")]),t._v(" 命名空间和作用域")]),t._v(" "),a("h2",{attrs:{id:"命名空间和作用域-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间和作用域-2"}},[t._v("#")]),t._v(" 命名空间和作用域")]),t._v(" "),a("h3",{attrs:{id:"命名空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间"}},[t._v("#")]),t._v(" 命名空间")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("命名空间是从名称到对象的映射，各个命名空间是相互独立的，其提供了一种在项目中避免名字冲突的方法。")])]),t._v(" "),a("li",[a("p",[t._v("一个命名空间中不能有重名，但不同命名空间中可以重名且没有任何影响")])]),t._v(" "),a("li",[a("p",[t._v("一般有三种命名空间")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("内置名称（built-in names")]),t._v(" ）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。")]),t._v(" "),a("li",[a("strong",[t._v("全局名称（global names）")]),t._v("  ，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。")]),t._v(" "),a("li",[a("strong",[t._v("局部名称（local names）")]),t._v("  ，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）")])])]),t._v(" "),a("li",[a("p",[t._v("命名空间的参照顺序为从里到外即："),a("strong",[t._v("局部的命名空间 -> 全局命名空间 -> 内置命名空间")]),t._v(" 。")])]),t._v(" "),a("li",[a("p",[t._v("命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。")]),t._v(" "),a("ul",[a("li",[t._v("因此我们无法从外部命名空间访问内部命名空间的对象")])])])]),t._v(" "),a("h3",{attrs:{id:"作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("作用于是一个Python程序可以直接访问命名空间的正文区域。")])]),t._v(" "),a("li",[a("p",[t._v("python程序中直接访问一个变量时会从内到外访问所有的作用域直到找到，否则报未定义的错误。")])]),t._v(" "),a("li",[a("p",[t._v("一共有四种作用域：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("L（Local）")]),t._v("  ：最内层，包含局部变量，比如一个函数/方法内部。")]),t._v(" "),a("li",[a("strong",[t._v("E（Enclosing）")]),t._v("  ：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。")]),t._v(" "),a("li",[a("strong",[t._v("G（Global）")]),t._v("  ：当前脚本的最外层，比如当前模块的全局变量。")]),t._v(" "),a("li",[a("strong",[t._v("B（Built-in）")]),t._v("  ： 包含了内建的变量/关键字等，最后被搜索。")])])]),t._v(" "),a("li",[a("p",[t._v("内置作用域通过一个builtin模块实现，但这个变量名本身并没有放入内置作用域，需要导入才能使用。")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" builtins\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("dir")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("builtins"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("python中只有模块，类和函数才会引入新的作用域，其他的则不会。")])]),t._v(" "),a("li",[a("p",[t._v("可以使用gloal和nonlocla关键字来修改外部作用域的变量。")])])]),t._v(" "),a("p",[t._v("‍")])])}),[],!1,null,null,null);a.default=v.exports}}]);