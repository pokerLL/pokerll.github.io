(window.webpackJsonp=window.webpackJsonp||[]).push([[274],{553:function(t,a,s){"use strict";s.r(a);var r=s(14),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"init-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#init-文件"}},[t._v("#")]),t._v(" "),a("code",[t._v("__init__")]),t._v("文件")]),t._v(" "),a("h2",{attrs:{id:"init-​文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#init-​文件"}},[t._v("#")]),t._v(" "),a("code",[t._v("__init__")]),t._v("​文件")]),t._v(" "),a("ul",[a("li",[t._v("Python3的包目录下会有一个"),a("code",[t._v("__init__.py")]),t._v("​文件，其目的是在"),a("code",[t._v("import package")]),t._v("​时自动执行一些内容-初始化")]),t._v(" "),a("li",[t._v("若包中还有子包，并且都有"),a("code",[t._v("__init__.py")]),t._v("​​文件，执行顺序为从外到里（记住这个文件的目的是导入包时自动进行初始化）")]),t._v(" "),a("li",[t._v("当没有"),a("code",[t._v("__init__.py")]),t._v("​文件时会有些不同，不是仅仅当默认存在一个空的"),a("code",[t._v("__init__")]),t._v("​文件，而是创建了一个所谓的命名空间包。")])]),t._v(" "),a("h3",{attrs:{id:"all-​"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#all-​"}},[t._v("#")]),t._v(" "),a("code",[t._v("__all__")]),t._v("​")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("可以在"),a("code",[t._v("__init__.py")]),t._v("​文件中使用"),a("code",[t._v("__all__")]),t._v("​控制import想要暴露出去的内容")])]),t._v(" "),a("li",[a("p",[t._v("使用"),a("code",[t._v("from ... import *")]),t._v("​ 的方式将会将一个模块的全部不以"),a("code",[t._v("_")]),t._v("​开头的内容导入到当前的命名空间，但这种方式不应该被过多使用-容易造成命名冲突。")])]),t._v(" "),a("li",[a("p",[t._v("python会进入文件系统，找到这个包所有的子模块并一一导入")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在大小写不区分的平台上（例如windows）会导致问题")]),t._v(" "),a("ul",[a("li",[t._v("例如无法确定ECHO.py导入为模块echo还是Echo还是ECHO")])])]),t._v(" "),a("li",[a("p",[t._v("可以在init.py中系统一个"),a("code",[t._v("__all__")]),t._v("​的列表变量，在使用import * 时将列表中的所有名字作为包内容导入")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[t._v("__all__ "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"echo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"surround"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"reverse"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("若没有"),a("code",[t._v("__all__")]),t._v("​则是暴露所有可以暴露的")])])]),t._v(" "),a("p",[t._v("‍")]),t._v(" "),a("h3",{attrs:{id:"import"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import"}},[t._v("#")]),t._v(" import")]),t._v(" "),a("p",[t._v("可以在"),a("code",[t._v("__init__.py")]),t._v("​中加载子模块用于做到在加载模块时自动加载子模块，此用法也常用于将多个文件合并为一个逻辑命名空间。")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# graphics/formats/__init__.py")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" jpg\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" png\n")])])]),a("p",[t._v("‍")]),t._v(" "),a("h2",{attrs:{id:"命名空间包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名空间包"}},[t._v("#")]),t._v(" 命名空间包")]),t._v(" "),a("p",[t._v("有两个目录存在相同的命名空间spam，但任何一个目录中都没有"),a("code",[t._v("__init__.py")]),t._v("​文件")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[t._v("foo"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("package"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n    spam"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n        blah"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("py\n\nbar"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("package"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n    spam"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n        grok"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("py\n")])])]),a("p",[t._v("可以通过都将其路径加入"),a("code",[t._v("sys.path")]),t._v("​中实现一个命名空间包-解释器创建了一个由所有包含匹配包名的目录组成的列表，通过这样的方式允许人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" sys\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" sys"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("extend"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo-package'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'bar-package'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" spam"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("blah\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" spam"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("grok\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" spam\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" spam"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__path__\n_NamespacePath"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo-package/spam'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'bar-package/spam'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("‍")])])}),[],!1,null,null,null);a.default=n.exports}}]);