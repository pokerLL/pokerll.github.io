(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{483:function(a,t,s){"use strict";s.r(t);var r=s(14),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"内存泄漏问题排查思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏问题排查思路"}},[a._v("#")]),a._v(" 内存泄漏问题排查思路")]),a._v(" "),t("h2",{attrs:{id:"内存泄漏问题排查思路-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏问题排查思路-2"}},[a._v("#")]),a._v(" 内存泄漏问题排查思路")]),a._v(" "),t("p",[a._v("对于Python进程内存泄漏问题定位，可以按如下步骤进行：")]),a._v(" "),t("ol",[t("li",[a._v("先确认下内存中一直保持增长的是什么类型对象")]),a._v(" "),t("li",[a._v("看看内存分配最频繁的地方是哪里")]),a._v(" "),t("li",[a._v("将这类占内存比较多的对象打印出来进行分析，看看是否有业务上信息")]),a._v(" "),t("li",[a._v("将重点怀疑的对象通过objgraph打印出引用关系从而分析出内存泄漏的问题源自哪里")])]),a._v(" "),t("p",[a._v("‍")]),a._v(" "),t("h2",{attrs:{id:"可能产生内存泄漏问题的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可能产生内存泄漏问题的场景"}},[a._v("#")]),a._v(" 可能产生内存泄漏问题的场景")]),a._v(" "),t("ul",[t("li",[t("p",[t("strong",[a._v("业务代码BUG")])]),a._v(" "),t("ul",[t("li",[a._v("代码中创建大量对象，虽然这些对象不再被访问，但是由于它们仍然被一些全局对象引用，GC无法释放这些对象。")]),a._v(" "),t("li",[a._v("容器无限制添加元素-list等一直append")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("未正确关闭文件句柄")]),a._v(": Python中的文件对象是与操作系统文件句柄相关联，如果文件对象没有被正确关闭，操作系统文件句柄无法释放，导致内存泄漏。")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("为正确释放C扩展模块或外部库中的内存")]),a._v(": 应用使用了C扩展模块或者外部库来扩展Python功能，如果其中存在内存泄漏则上层应用运行时也会内存泄漏。")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("循环引用")]),a._v(": Python 的垃圾回收机制是基于引用计数的，当一个对象的引用计数为 0 时，垃圾回收机制会自动回收这个对象。如果存在循环引用，即两个或多个对象相互引用，导致它们的引用数不会变为 0，垃圾回收机制无法回收这些对象，从而导致内存泄漏。")]),a._v(" "),t("blockquote",[t("p",[a._v("存疑，python有标记清除算法来避免循环引用，一般不会出现这个问题。标记清除法、 标记清除算法")])])]),a._v(" "),t("li",[t("p",[a._v("‍")])])]),a._v(" "),t("p",[a._v("‍")]),a._v(" "),t("h2",{attrs:{id:"排查工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排查工具"}},[a._v("#")]),a._v(" 排查工具")]),a._v(" "),t("h3",{attrs:{id:"objgraph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#objgraph"}},[a._v("#")]),a._v(" Objgraph")]),a._v(" "),t("p",[a._v("这是一个可以用来查看对象间引用关系的工具，比如对于一些大对象总是不释放的问题，可以通过这个工具分析出其到底是被哪些对象所引用。")]),a._v(" "),t("h4",{attrs:{id:"工具安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具安装"}},[a._v("#")]),a._v(" 工具安装")]),a._v(" "),t("div",{staticClass:"language-arduino extra-class"},[t("pre",{pre:!0,attrs:{class:"language-arduino"}},[t("code",[a._v("pip install objgraph         "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 安装objgraph")]),a._v("\npip install xdot             "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 安装可视化依赖库")]),a._v("\npip install  graphviz        "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 安装绘图依赖库")]),a._v("\napt"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("get")]),a._v(" install graphviz     "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 安装绘图工具")]),a._v("\n")])])]),t("h4",{attrs:{id:"使用介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用介绍"}},[a._v("#")]),a._v(" 使用介绍")]),a._v(" "),t("p",[a._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/62dc27aa675146d0baa41e74d44804dbtplv-k3u1fbpfcp-jj-mark3024000q75-20230911160214-ussmcy8.awebp",alt:"image.png"}}),a._v("​")]),a._v(" "),t("p",[a._v("上面代码构造了一个循环引用的场景，通过objgrap可以看到对象引用关系图如下：")]),a._v(" "),t("p",[a._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/fc73a9312c4b4b33bc313fb947ccbfcatplv-k3u1fbpfcp-jj-mark3024000q75-20230911160214-yhuz97x.awebp",alt:"image.png"}}),a._v("​")]),a._v(" "),t("p",[t("em",[a._v("注意：此工具在生成对象间引用关系时是一个比较耗时的操作，需要确保执行频率不要太高以免影响业务代码流程，而且我们也没必要每次都要将内存中所有对象引用关系都搞出来，这样不仅耗时而且也难以分析。")])]),a._v(" "),t("h3",{attrs:{id:"pympler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pympler"}},[a._v("#")]),a._v(" pympler")]),a._v(" "),t("p",[a._v("此工具可以方便获取到当前内存使用情况，比如过去占用内存最多的前十个对象类型，对象个数以及占用内存字节。")]),a._v(" "),t("h4",{attrs:{id:"工具安装-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具安装-2"}},[a._v("#")]),a._v(" 工具安装")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("pip install pympler\n")])])]),t("h4",{attrs:{id:"使用介绍-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用介绍-2"}},[a._v("#")]),a._v(" 使用介绍")]),a._v(" "),t("p",[a._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/3575e917ab32448c97b9c7e359c37f99tplv-k3u1fbpfcp-jj-mark3024000q75-20230911160214-x1ypg50.awebp",alt:"image.png"}}),a._v("​")]),a._v(" "),t("p",[a._v("上述代码构造了一个字符串和一个字典，通过pympler可以看到str和dict类型在内存中数据量。")]),a._v(" "),t("p",[a._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/f085b03a049b43d7a8f52eea011a66d6tplv-k3u1fbpfcp-jj-mark3024000q75-20230911160214-v1ixssv.awebp",alt:"image.png"}}),a._v("​")]),a._v(" "),t("h3",{attrs:{id:"tracemalloc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tracemalloc"}},[a._v("#")]),a._v(" tracemalloc")]),a._v(" "),t("p",[a._v("tracemalloc是一个用于跟踪Python应用内存分配的工具，在python3.4以上此工具为标准库，所以无需安装。")]),a._v(" "),t("h4",{attrs:{id:"使用介绍-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用介绍-3"}},[a._v("#")]),a._v(" 使用介绍")]),a._v(" "),t("p",[a._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/160cb0813fc74ca29f122e60fae07d15tplv-k3u1fbpfcp-jj-mark3024000q75-20230911160214-c72diyw.awebp",alt:"image.png"}}),a._v("​")]),a._v(" "),t("p",[a._v("我们可以看到tracemalloc不仅可以获取占内存最多的对象，同时也能看到改对象创建的堆栈。")]),a._v(" "),t("p",[a._v("​"),t("img",{attrs:{src:"https://assets.b3logfile.com/siyuan/xxxxxx/assets/c256f6810583417cb72d911d860b0fddtplv-k3u1fbpfcp-jj-mark3024000q75-20230911160214-qk1npy0.awebp",alt:"image.png"}}),a._v("​")]),a._v(" "),t("p",[a._v("‍")]),a._v(" "),t("p",[a._v("‍")])])}),[],!1,null,null,null);t.default=v.exports}}]);