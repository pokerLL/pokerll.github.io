(window.webpackJsonp=window.webpackJsonp||[]).push([[359],{638:function(t,e,i){"use strict";i.r(e);var n=i(14),s=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("h2",{attrs:{id:"deterministic-profiling-statistical-profiling"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#deterministic-profiling-statistical-profiling"}},[t._v("#")]),t._v(" Deterministic Profiling & Statistical Profiling")]),t._v(" "),e("p",[e("em",[t._v("Deterministic profiling")]),t._v(" is meant to reflect the fact that all "),e("em",[t._v("function call")]),t._v(", "),e("em",[t._v("function return")]),t._v(", and "),e("em",[t._v("exception")]),t._v(" events are monitored, and precise timings are made for the intervals between these events (during which time the user's code is executing).")]),t._v(" "),e("p",[t._v("In contrast, "),e("em",[t._v("statistical profiling")]),t._v(" (which is not done by this module) randomly samples the effective instruction pointer, and deduces where time is being spent. The latter technique traditionally involves less overhead (as the code does not need to be instrumented), but provides only relative indications of where time is being spent.")]),t._v(" "),e("blockquote",[e("ol",[e("li",[e("strong",[t._v("确定性分析")]),t._v("： 确定性分析旨在监测所有函数调用、函数返回和异常事件，并精确记录这些事件之间的时间间隔（即用户代码执行期间的时间）。这种方法通过跟踪每个函数调用、返回和异常事件的发生时间来测量代码执行时间。这种方式的优点是提供了精确的时间和执行路径信息，能够准确地确定代码中时间开销较大的部分。")]),t._v(" "),e("li",[e("strong",[t._v("统计性分析")]),t._v("： 统计性分析（本模块不执行此类分析）则是随机抽样有效指令指针，并推断代码执行的时间分布。它并不监测每个事件，而是以随机采样的方式来推断程序中时间花费的位置。这种技术通常需要较少的开销（因为代码不需要被修改以添加监测逻辑），但只提供了时间分布的相对指示，无法提供像确定性分析那样精确的时间和执行路径信息。")])]),t._v(" "),e("p",[t._v("在实际应用中，确定性分析提供了更准确的时间测量和代码路径跟踪，但会导致较大的性能开销。而统计性分析则以较低的开销提供了时间分布的概要信息，但不提供详细的执行路径和准确的时间测量。")])]),t._v(" "),e("p",[t._v("In Python, since there is an interpreter active during execution, the presence of instrumented code is not required in order to do deterministic profiling. Python automatically provides a "),e("em",[t._v("hook")]),t._v(" (optional callback) for each event. In addition, the interpreted nature of Python tends to add so much overhead to execution, that deterministic profiling tends to only add small processing overhead in typical applications. The result is that deterministic profiling is not that expensive, yet provides extensive run time statistics about the execution of a Python program.")]),t._v(" "),e("blockquote",[e("p",[t._v("oevrhead：执行特定操作或功能时所产生的额外成本、开销或负担")])]),t._v(" "),e("p",[t._v('Call count statistics can be used to identify bugs in code (surprising counts), and to identify possible inline-expansion points (high call counts). Internal time statistics can be used to identify "hot loops" that should be carefully optimized. Cumulative time statistics should be used to identify high level errors in the selection of algorithms. Note that the unusual handling of cumulative times in this profiler allows statistics for recursive implementations of algorithms to be directly compared to iterative implementations.')]),t._v(" "),e("p",[t._v("‍")]),t._v(" "),e("h2",{attrs:{id:"性能优化概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化概述"}},[t._v("#")]),t._v(" 性能优化概述")]),t._v(" "),e("p",[t._v("对于和性能有关的一切事情，第一件事就是先判断是不是需要好的性能，然后多好的性能才算好。这是很多人都忽视的一点。总觉得哎我这里需要压榨性能，有时候这甚至不是bottleneck。  如果保证不重复，是100%用set的，list里in的判断是O(N)的，这里平白无故多了个判断。  无论是往list里还是往set里塞东西，其实性能的提升空间都非常有限，你的工作量在那儿呢。大部分时候也根本不需要去压性能。但是如果你真的通过了profiling发现这里确实是critical path，每一点点性能都极为关键，那这里可以用一个常见的小技巧。")]),t._v(" "),e("p",[t._v("更简单的说就是：发明汽车时就不要考虑其在超音速下的稳定性。")])])}),[],!1,null,null,null);e.default=s.exports}}]);