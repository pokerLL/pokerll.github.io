(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{358:function(t,e,a){"use strict";a.r(e);var s=a(14),n=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"backoff-自动重试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#backoff-自动重试"}},[t._v("#")]),t._v(" backoff-自动重试")]),t._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("Backoff是一个Python库，用于实现在重试过程中添加指数退避（exponential backoff）策略的功能。重试和退避是在网络请求、数据库连接等场景中常见的处理方式，用于应对临时性的错误或超时情况。")]),t._v(" "),e("p",[t._v("该库的核心目标是在请求失败时，通过指数退避的方式逐渐增加重试时间间隔，以减轻服务器负担，并提高请求成功率。这种退避策略意味着在失败后等待一段时间后再次尝试，然后在每次失败后的等待时间逐渐增加。")]),t._v(" "),e("p",[t._v("Backoff库提供了简单易用的装饰器和函数调用方式，可以轻松地在需要重试的函数或方法上添加退避策略。它还可以定制退避策略的参数，如初始延迟时间、最大重试次数和退避倍数。")]),t._v(" "),e("p",[t._v("除了常用的"),e("code",[t._v("@backoff.on_exception")]),t._v("​，Backoff库还提供了其他几个装饰器，用于在不同的情况下应用退避策略。这些装饰器可以根据函数的返回值、异常类型和特定条件来触发重试。以下是Backoff库中的主要装饰器：")]),t._v(" "),e("ol",[e("li",[t._v("​"),e("code",[t._v("@backoff.on_predicate(predicate, max_tries=None, max_time=None, jitter=None)")]),t._v("​: 使用此装饰器时，您需要定义一个predicate函数，它应该在每次重试时被调用。只要predicate函数返回"),e("code",[t._v("False")]),t._v("​，则会触发重试。可以使用"),e("code",[t._v("max_tries")]),t._v("​参数来设置最大重试次数，使用"),e("code",[t._v("max_time")]),t._v("​参数设置最大重试时间，使用"),e("code",[t._v("jitter")]),t._v("​参数来添加抖动，以使重试时间稍微变化，避免同时重试。")]),t._v(" "),e("li",[t._v("​"),e("code",[t._v("@backoff.on_exception")]),t._v("​（已在之前的示例中介绍过）: 使用此装饰器时，您可以指定某个异常类型，当被指定的异常出现时，会触发重试。")]),t._v(" "),e("li",[t._v("​"),e("code",[t._v("@backoff.on_predicate_try(predicate, max_tries=None, max_time=None, jitter=None)")]),t._v("​: 类似于"),e("code",[t._v("@backoff.on_predicate")]),t._v("​，不同之处在于predicate函数的返回值应该是一个元组"),e("code",[t._v("(should_retry, result)")]),t._v("​，其中"),e("code",[t._v("should_retry")]),t._v("​是"),e("code",[t._v("True")]),t._v("​或"),e("code",[t._v("False")]),t._v("​，用于指示是否重试，而"),e("code",[t._v("result")]),t._v("​是要返回的结果。这样可以在predicate函数中实现更细粒度的控制。")]),t._v(" "),e("li",[t._v("​"),e("code",[t._v("@backoff.on_iteration(iteration, max_tries=None, max_time=None, jitter=None)")]),t._v("​: 使用此装饰器，您可以指定一个回调函数"),e("code",[t._v("iteration")]),t._v("​，它在每次重试时被调用，并接收一个参数"),e("code",[t._v("iteration")]),t._v("​，表示当前的重试次数。")])]),t._v(" "),e("p",[t._v("这些装饰器可以根据不同的需求和场景选择使用。它们允许您在不同的条件下灵活地应用指数退避策略，以便更好地控制函数的重试行为。可以根据具体的应用场景来选择合适的装饰器，并设置适当的参数来实现自定义的重试策略。")]),t._v(" "),e("p",[t._v("‍")]),t._v(" "),e("h2",{attrs:{id:"示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("下面是一个简单的示例代码，演示了如何使用Backoff库来添加指数退避策略：")]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" backoff\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 定义重试函数并添加退避装饰器")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token decorator annotation punctuation"}},[t._v("@backoff"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("on_exception")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("backoff"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("expo"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Exception"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" max_time"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("make_request")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 模拟一个可能失败的网络请求")]),t._v("\n    response "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" perform_network_request"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 检查响应是否成功，如果失败则抛出异常")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" response"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ok"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("raise")]),t._v(" Exception"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Request failed"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" response\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 调用重试函数")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    response "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" make_request"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Request succeeded with response:"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" response"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("except")]),t._v(" Exception "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Failed to make request after retries:"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("在上述代码中，"),e("code",[t._v("make_request")]),t._v("​函数可能因为网络请求失败而抛出异常。使用Backoff库的装饰器"),e("code",[t._v("@backoff.on_exception")]),t._v("​，我们指定了"),e("code",[t._v("backoff.expo")]),t._v("​作为退避策略，表示采用指数退避。在这个例子中，最大重试时间设置为60秒，表示如果请求在60秒内仍然失败，就不再进行重试。")]),t._v(" "),e("p",[t._v("当"),e("code",[t._v("make_request")]),t._v("​函数抛出异常时，Backoff库会自动进行重试，每次重试的等待时间会逐渐增加，直到请求成功或达到最大重试次数。")]),t._v(" "),e("p",[t._v("总体而言，Backoff库为Python开发者提供了一种简便的方式来实现重试和退避策略，有效地处理在网络通信和其他场景中可能遇到的临时性错误。")]),t._v(" "),e("p",[t._v("‍")])])}),[],!1,null,null,null);e.default=n.exports}}]);