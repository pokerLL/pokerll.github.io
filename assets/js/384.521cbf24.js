(window.webpackJsonp=window.webpackJsonp||[]).push([[384],{662:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"协议和鸭子类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协议和鸭子类型"}},[t._v("#")]),t._v(" 协议和鸭子类型")]),t._v(" "),s("h2",{attrs:{id:"鸭子类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#鸭子类型"}},[t._v("#")]),t._v(" 鸭子类型")]),t._v(" "),s("p",[t._v("在计算机编程中，鸭子类型（Duck typing）是一种动态语言中的编程风格，它关注于对象的行为（方法和属性）而不是对象的类型。鸭子类型的核心思想可以用这样一句话来概括： "),s("strong",[t._v("“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。”")])]),t._v(" "),s("p",[t._v("在Python中，鸭子类型意味着一个对象的适用性不是基于它所属的类（或类型），而是基于它是否具有特定的方法或属性。例如，如果一个对象具有"),s("code",[t._v("quack()")]),t._v("​和"),s("code",[t._v("fly()")]),t._v("​方法，那么它被视为“鸭子”，不管它是不是真的属于鸭子类。这种方法的优势在于它可以增加代码的灵活性和可重用性，因为你不需要依赖于对象的具体类型，只需关心对象是否能够执行特定的操作。")]),t._v(" "),s("p",[t._v("下面是一个简单的示例，演示了鸭子类型的概念：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Duck")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Quack, quack!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fly")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Flap, flap!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Airplane")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fly")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Zoom, zoom!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make_it_quack_and_fly")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("thing"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    thing"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("quack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    thing"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fly"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nduck "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Duck"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nairplane "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Airplane"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nmake_it_quack_and_fly"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("duck"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 输出：Quack, quack! Flap, flap!")]),t._v("\nmake_it_quack_and_fly"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("airplane"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 输出：Zoom, zoom!")]),t._v("\n")])])]),s("p",[t._v("在这个例子中，"),s("code",[t._v("make_it_quack_and_fly()")]),t._v("​函数接受一个对象作为参数，然后调用该对象的"),s("code",[t._v("quack()")]),t._v("​和"),s("code",[t._v("fly()")]),t._v("​方法。无论是Duck类的实例还是Airplane类的实例，只要它们具有这两个方法，就可以被"),s("code",[t._v("make_it_quack_and_fly()")]),t._v("​函数接受，这就是鸭子类型的体现。")]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("h2",{attrs:{id:"白鹅类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#白鹅类型"}},[t._v("#")]),t._v(" 白鹅类型")]),t._v(" "),s("p",[t._v("白鹅类型是在流畅的python一书中提出的一个概念，其指的是只要一个类是抽象基类，即其元类是"),s("code",[t._v("abc.ABCMeata")]),t._v("​，就应该特殊实现"),s("code",[t._v("isinstance(obj, cls)")]),t._v("​方法，即是否是其子类不再由继承关系确定，而是由是否完全实现其内部抽象方法决定。")]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("h2",{attrs:{id:"协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[t._v("#")]),t._v(" 协议")]),t._v(" "),s("p",[t._v("在Python中，协议（protocol）是一种编程约定或规范，它描述了对象应该具有哪些方法、属性或行为。Python是一种动态类型语言，它不会强制要求对象必须属于特定的类或继承自特定的基类。相反，Python更关注于对象的行为，即对象能够做什么，而不是它是什么。")]),t._v(" "),s("p",[t._v("协议的概念强调了接口的重要性，即对象应该提供哪些方法以便其他对象可以与之交互。例如，迭代器协议规定了一个对象必须实现"),s("code",[t._v("__iter__()")]),t._v("​和"),s("code",[t._v("__next__()")]),t._v("​方法，以便可以在"),s("code",[t._v("for")]),t._v("​循环中使用。只要对象符合这个协议，它就可以被用于"),s("code",[t._v("for")]),t._v("​循环中，不管它的具体类型是什么。")]),t._v(" "),s("p",[t._v("以下是一个示例，演示了如何使用协议来实现一个简单的迭代器：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyIterator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" start"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" end"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" start\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("end "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" end\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__iter__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" self\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__next__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("end"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("raise")]),t._v(" StopIteration\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用自定义的迭代器")]),t._v("\nmy_iterator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" MyIterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" num "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" my_iterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 输出：1 2 3 4")]),t._v("\n")])])]),s("p",[t._v("在这个例子中，"),s("code",[t._v("MyIterator")]),t._v("​类符合迭代器协议，因此可以在"),s("code",[t._v("for")]),t._v("​循环中使用。协议是一种灵活的方式，可以让你定义自己的接口和规范，而不受特定基类的限制。这种灵活性使得Python成为一个非常强大和适应性强的编程语言。")])])}),[],!1,null,null,null);s.default=e.exports}}]);