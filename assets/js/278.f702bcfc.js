(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{557:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"模块化概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化概述"}},[t._v("#")]),t._v(" 模块化概述")]),t._v(" "),s("h2",{attrs:{id:"sys-path​"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sys-path​"}},[t._v("#")]),t._v(" "),s("code",[t._v("sys.path")]),t._v("​")]),t._v(" "),s("ul",[s("li",[s("p",[t._v('包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。')]),t._v(" "),s("ul",[s("li",[t._v("比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。")]),t._v(" "),s("li",[t._v("就好像使用模块的时候，不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。")])])]),t._v(" "),s("li",[s("p",[t._v("搜索路径是一个解释器会先进行搜索的所有目录的列表。当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("搜索路径被存储在sys模块的path变量中（不是windows环境变量下的那个PATH）")]),t._v(" "),s("ul",[s("li",[t._v("Linux和Windows下都是"),s("code",[t._v("PYTHONPATH")]),t._v("​环境变量")]),t._v(" "),s("li",[t._v("如果设置了"),s("code",[t._v("PYTHONPATH")]),t._v("​环境变量，则会覆盖掉默认搜索路径")])])]),t._v(" "),s("li",[s("p",[t._v("​"),s("code",[t._v("path")]),t._v("​输出是一个列表，由一系列目录名组成，第一项是一个空串表示当前目录。")])]),t._v(" "),s("li",[s("p",[t._v("​"),s("code",[t._v('sys.path.append("..")')]),t._v("​ 表示将当前程序所在位置向上提了一级")])])])]),t._v(" "),s("li",[s("p",[t._v("可以创建一个"),s("code",[t._v(".pth")]),t._v("​文件访问Python安装路径下的"),s("code",[t._v("site-packages/sitepackages")]),t._v("​目录，这样解释器启动时会自动将其中列举出的目录加入到"),s("code",[t._v("sys.path")]),t._v("​中")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# myapplication.pth")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("some"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("dir")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("other"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("dir")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("​"),s("code",[t._v("__init__")]),t._v("​文件是Python2的要求，Python3并不强制要求")])]),t._v(" "),s("li",[s("p",[t._v("一个模块只会被导入一次，不管你执行了多少次"),s("code",[t._v("import")]),t._v("​，这样可以防止导入模块被一遍又一遍地执行。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("使用reload方法重新导入")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" aaa\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" imp "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("reload")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("reload")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("aaa"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])])]),t._v(" "),s("li",[s("p",[t._v("import 在导入文件的时候，会自动把所有暴露在外面的代码全都执行一遍（第一次导入时）。因此，如果你要把一个东西封装成模块，又想让它可以执行的话，你必须将要执行的代码放在 "),s("code",[t._v("if __name__ == '__main__'")]),t._v("​​下面。")]),t._v(" "),s("ul",[s("li",[t._v("​"),s("code",[t._v("__name__")]),t._v("​​作为Python 的魔术内置参数，本质上是模块对象的一个属性。我们使用 import 语句时，"),s("code",[t._v("__name")]),t._v("​​就会被赋值为该模块的名字，自然就不等于 "),s("code",[t._v("__main__")]),t._v("​​了。")]),t._v(" "),s("li",[t._v("巧用"),s("code",[t._v("if __name__== '__main__'")]),t._v("​​来避开 import 时执行。")])])])]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" sys\nsys"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('".."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" utils"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("class_utils "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n\nencoder "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Encoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndecoder "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Decoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("encoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("encode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abcde'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("decoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("decode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'edcba'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("########## 输出 ##########")]),t._v("\n\nedcba\nabcde\n\n")])])]),s("p",[t._v("‍")]),t._v(" "),s("h2",{attrs:{id:"项目模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#项目模块化"}},[t._v("#")]),t._v(" 项目模块化")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("相对位置会使得重构既不雅观，也易出错。因此，在大型工程中尽可能使用绝对位置是第一要义。对于一个独立的项目，所有的模块的追寻方式，最好从项目的根目录开始追溯，这叫做相对的绝对路径。")]),t._v(" "),s("ul",[s("li",[t._v("以项目的根目录作为最基本的目录，所有的模块调用，都要通过根目录一层层向下索引的方式来 import。")])])])]),t._v(" "),s("p",[t._v("‍")]),t._v(" "),s("h2",{attrs:{id:"猴子补丁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#猴子补丁"}},[t._v("#")]),t._v(" 猴子补丁")]),t._v(" "),s("p",[t._v("“猴子补丁”是动态类型语言的一个特性，代码运行时在不修改源代码的前提下改变代码中的方法、属性、函数等以达到热补丁（hot patch）的效果。很多系统的安全补丁也是通过猴子补丁的方式来实现的，但实际开发中应该避免对猴子补丁的使用，以免造成代码行为不一致的问题。")]),t._v(" "),s("p",[t._v("Monkey-patching猴子补丁这个叫法源自于Zope框架，大家在修正Zope的Bug时经常会在程序后追加更新部分，这些被称作“杂牌军补丁（guerillapatch）”，后来"),s("code",[t._v("guerilla")]),t._v("​逐渐写成了"),s("code",[t._v("gorllia")]),t._v("​（猩猩），再后来就写成了"),s("code",[t._v("monkey")]),t._v("​（猴子），所以猴子补丁的叫法就这么莫名其妙的得来了。之后在动态语言中，不改变源代码而对功能进行追加和变更就统称为“猴子补丁”。所以猴子补丁并不是Python中专有的，猴子补丁充分利用了动态语言的灵活性，可以对现有语言API进行追加、替换、修改，甚至性能优化等。")]),t._v(" "),s("p",[t._v("在使用"),s("code",[t._v("gevent")]),t._v("​库的时候，我们会在代码开头的地方执行"),s("code",[t._v("gevent.monkey.patch_all()")]),t._v("​，这行代码的作用是把标准库中的"),s("code",[t._v("socket")]),t._v("​模块给替换掉，这样我们在使用"),s("code",[t._v("socket")]),t._v("​的时候，不用修改任何代码就可以实现对代码的协程化，达到提升性能的目的，这就是对猴子补丁的应用。")]),t._v(" "),s("p",[t._v("另外，如果希望用"),s("code",[t._v("ujson")]),t._v("​三方库替换掉标准库中的"),s("code",[t._v("json")]),t._v("​，也可以使用猴子补丁的方式，代码如下所示。")]),t._v(" "),s("div",{staticClass:"language-Python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" json"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ujson\n\njson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__name__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ujson'")]),t._v("\njson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dumps "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ujson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dumps\njson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loads "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ujson"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loads\n")])])]),s("p",[t._v("单元测试中的"),s("code",[t._v("Mock")]),t._v("​技术也是对猴子补丁的应用，Python中的"),s("code",[t._v("unittest.mock")]),t._v("​模块就是解决单元测试中用"),s("code",[t._v("Mock")]),t._v("​对象替代被测对象所依赖的对象的模块。")]),t._v(" "),s("p",[t._v("‍")])])}),[],!1,null,null,null);s.default=e.exports}}]);